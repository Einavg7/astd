---
title: "lec5b"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Geostatistical prediction

Linear predictors:
$$\hat{Z}(s_0) = \sum_{i=1}^n \lambda_i Z(s_i)$$

Precition weights are such that the prediction error $\hat{Z}(s_0)-Z(s_0)$ has expectation zero and minimal variance; this involves inverting the covariance matrix of $Z=\{Z(s_1),...,Z(s_n)\}$.

## Demo case:

### Model variogram:
```{r}
library(sp)
demo(meuse, ask = FALSE)
library(gstat)
v = variogram(log(zinc)~1, meuse)
v.fit = fit.variogram(v, vgm(1, "Sph", 900, 1))
plot(v, v.fit)
```

### Use in prediction:
```{r}
k = krige(log(zinc)~1, meuse, meuse.grid, v.fit)
spplot(k["var1.pred"], main = "log(zinc) predictions")
```

### How to create a prediction grid like `meuse.grid` from scratch?

Method 1: from x and y coordinates
```{r}
x = seq(50, 2000, 75)
y = seq(350, 1200, 75)
df = expand.grid(x = x, y = y)
head(df)
grd = SpatialPoints(df)
gridded(grd) = TRUE
summary(grd)
plot(grd, axes = TRUE)
points(50, 350, col  = 'red')
```

Method 2: from a polygon, e.g. a shapefile read by `rgdal::readOGR`. Here, we'll start with `meuse.area`
```{r}
summary(meuse.area)
grd = spsample(meuse.area, type = 'regular', cellsize = 100)
summary(grd)
plot(grd, cex = .3)
grd[1:3]
# get nice coordinate values: fix offset
grd = spsample(meuse.area, type = 'regular', offset = c(0,0), cellsize = 100)
grd[1:3]
```

## Next:

read all vignettes of the gstat package except for vignette ``prs'':
```{r eval = FALSE}
vignette(package = "gstat")
vignette("gstat")
```
Try to run the code yourself with

```{r eval=FALSE}
edit(vignette("gstat"))
```

and copy-and-paste.
